= LiveAssets

This project rocks and uses MIT-LICENSE.

####Notes:
* Goal is to make a write a Rails plugin that streams data to the browser whenever a stylesheet changes.
* Leverages Rails engines, which allow plugins to have their own controllers, models, views, and routes.
* Rails engines use the Paths interface and initializers
  1. The Paths interface
    - which allows you to specify where to load controllers, models, etc. from
  2. Initializers
    - Low-level, handle tasks such as attaching views to ActionController & ActionMailer
      as soon as they are loaded.
    - Initializers are available by querying `Rails::Engine.initializers`

* Live-streaming is made possible by including the `ActionController::LiveStreaming` functionality.
  - _Server Sent Events_(SSE), which was included in the HTML5 specification
  - Enables servers to send events to the client
  - Each message is delimited as follows:

  ````
  event: some_channel
  data: some_data
  ````

* V1 simply sends an event to the browser using the SSE protocol, and the browser reloads all stylesheets
* There are 3 things to improve upon V1:
  1. ######Instead of sending the event every second, only send the event when something changes
    - Install the listen gem
    - In a thread, listen to changes in the filesystem
    - When changes are detected, push the event out to all of the subscribers
  2. ######Write tests
    - Decouple the file system watching from the streaming
    - Setup by subscribing, writing to a file, and then verifying the subscriber got written to
  3. ######Understand how enabling concurrency will affect deployment

* In building out V1, the architecture is as follows:
  - Start up a listener on initialization to look at
    `app/assets`, `lib/assets`, and `vendor/assets`
    Think: 'This is an event subscribers should be notified of'
  - Every time a request comes in to `live_assets/sse`, create a new subscriber.
    Think: 'This browser should be notified of this event'
  - We then wait until an event happens, after which we stream the event to subscribers.
  - Use a queue to manage this "waiting" behavior; when the queue is empty, the request will go to sleep. When an event arrives, it will wake up and notify the subscribers.
  - This requires we rewrite the controller to use an SSESubscriber that gets notified when an event is added to the queue, it will then write to the stream.
  - Finally, we need to ensure the connection between browser and server won't be closed if there is no activity for long periods by writing a script to ping every 10 seconds.

* Autoloading/concurrency/deployment considerations:
  - Rails autoloading is not thread-safe
  - This means that if thread A is loading a controller, and then thread B tries to load the controller, it is possible that thread B will only load a partial implementation of said controller (if thread A had not finished loading it by the time thread B used it).
  - To solve this, Rails only allows one thread to run at once, which means it can only serve one request at a time.

  How do you handle this limitation in a production environment?
  - In production, Rails eager-loads all code in the app/ directory, so there is no autoloading to be done.
  - However, if we're relying on Ruby autoload, we need to eager-load the code ourselves, otherwise we could wind up loading code in the middle of a request.
  - Thus, we need to make sure anything we want to eager-load using Ruby is done when the application boots.

